<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Story Mode | Death2Data</title>
<meta name="description" content="Read the web in story mode. Card-by-card. No distractions.">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<meta name="theme-color" content="#0a0a0a">
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@700&family=Newsreader:ital,wght@0,400;0,600;1,400&display=swap');

/* === VARIABLES — matches D2D site === */
:root {
  --bg: #0a0a0a;
  --surface: #111111;
  --border: #1e1e1e;
  --border-hover: #2a3a2a;
  --green: #00cc44;
  --green-dim: #004d1a;
  --green-hover: #00e64d;
  --red: #cc0000;
  --white: #e0e0e0;
  --gray: #b0b0b0;
  --muted: #666666;
  --dim: #444444;
  --font: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  --mono: 'JetBrains Mono', monospace;
  --serif: 'Newsreader', Georgia, 'Times New Roman', serif;
}

*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
html, body { height:100%; overflow:hidden; }
body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--white);
  -webkit-font-smoothing: antialiased;
}

/* === STORY CONTAINER === */
.story-container {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  background: var(--bg);
  z-index: 1000;
}

/* === TOP BAR === */
.story-bar {
  display: flex;
  align-items: center;
  padding: 0 16px;
  height: 48px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  gap: 12px;
}
.story-bar .logo {
  font-family: var(--mono);
  font-weight: 700;
  font-size: 13px;
  color: var(--green);
  letter-spacing: 1px;
}
.story-bar .mode-tag {
  font-size: 10px;
  letter-spacing: 2px;
  color: var(--dim);
  text-transform: uppercase;
}
.story-bar .spacer { flex:1; }
.story-bar .source-url {
  font-size: 11px;
  color: var(--muted);
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.story-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--muted);
  font-size: 16px;
  cursor: pointer;
  flex-shrink: 0;
}
.story-close:hover { border-color: var(--muted); color: var(--white); }

/* === PROGRESS BAR === */
.progress-track {
  display: flex;
  gap: 3px;
  padding: 8px 16px;
  flex-shrink: 0;
}
.progress-seg {
  flex: 1;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
  transition: background 0.3s;
}
.progress-seg.done { background: var(--green); }
.progress-seg.active {
  background: var(--border);
}
.progress-seg.active .progress-fill {
  display: block;
  height: 100%;
  background: var(--green);
  border-radius: 2px;
  animation: fillSeg 8s linear forwards;
}
.progress-fill { display: none; }
@keyframes fillSeg {
  from { width: 0; }
  to { width: 100%; }
}

/* === CARD VIEWPORT === */
.card-viewport {
  flex: 1;
  position: relative;
  overflow: hidden;
  touch-action: pan-y;
}

/* === STORY CARD === */
.story-card {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 40px 24px;
  opacity: 0;
  transform: translateX(100%);
  transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
}
.story-card.active {
  opacity: 1;
  transform: translateX(0) rotateY(0);
}
.story-card.prev {
  opacity: 0;
  transform: translateX(-100%);
}
.story-card.entering-right {
  transform: translateX(100%);
  opacity: 0;
}
.story-card.entering-left {
  transform: translateX(-100%);
  opacity: 0;
}

/* Card inner container */
.card-inner {
  max-width: 520px;
  width: 100%;
  text-align: left;
}

/* === CARD TYPES === */

/* -- HEADLINE card -- */
.card-headline .card-label {
  font-size: 10px;
  letter-spacing: 3px;
  color: var(--green);
  text-transform: uppercase;
  margin-bottom: 16px;
}
.card-headline h1 {
  font-family: var(--serif);
  font-size: clamp(28px, 6vw, 42px);
  font-weight: 600;
  line-height: 1.2;
  color: var(--white);
  margin-bottom: 16px;
}
.card-headline .card-source {
  font-size: 12px;
  color: var(--muted);
  display: flex;
  align-items: center;
  gap: 8px;
}
.card-headline .card-source img {
  width: 16px; height: 16px; border-radius: 2px;
}

/* -- KEYPOINT card -- */
.card-keypoint .kp-number {
  font-family: var(--mono);
  font-size: 48px;
  font-weight: 700;
  color: var(--green-dim);
  margin-bottom: 8px;
}
.card-keypoint h2 {
  font-family: var(--serif);
  font-size: clamp(22px, 5vw, 32px);
  font-weight: 600;
  line-height: 1.3;
  color: var(--white);
  margin-bottom: 12px;
}
.card-keypoint p {
  font-size: 15px;
  line-height: 1.7;
  color: var(--gray);
}

/* -- QUOTE card -- */
.card-quote {
  text-align: center;
}
.card-quote .quote-mark {
  font-family: var(--serif);
  font-size: 64px;
  color: var(--green-dim);
  line-height: 1;
  margin-bottom: -8px;
}
.card-quote blockquote {
  font-family: var(--serif);
  font-size: clamp(20px, 5vw, 28px);
  font-style: italic;
  line-height: 1.5;
  color: var(--white);
  margin-bottom: 16px;
}
.card-quote .quote-attr {
  font-size: 13px;
  color: var(--muted);
}

/* -- STAT card -- */
.card-stat {
  text-align: center;
}
.card-stat .stat-value {
  font-family: var(--mono);
  font-size: clamp(48px, 12vw, 80px);
  font-weight: 700;
  color: var(--green);
  line-height: 1;
  margin-bottom: 8px;
}
.card-stat .stat-label {
  font-size: 16px;
  color: var(--gray);
  margin-bottom: 16px;
}
.card-stat .stat-context {
  font-size: 13px;
  color: var(--muted);
  line-height: 1.6;
}

/* -- BODY card (paragraph content) -- */
.card-body p {
  font-family: var(--serif);
  font-size: clamp(17px, 4vw, 20px);
  line-height: 1.8;
  color: var(--gray);
}
.card-body p strong {
  color: var(--white);
  font-weight: 600;
}

/* -- LIST card -- */
.card-list h3 {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--green);
  text-transform: uppercase;
  margin-bottom: 20px;
}
.card-list .list-item {
  display: flex;
  gap: 12px;
  padding: 12px 0;
  border-bottom: 1px solid var(--border);
}
.card-list .list-item:last-child { border-bottom: none; }
.card-list .list-num {
  font-family: var(--mono);
  font-size: 14px;
  color: var(--green-dim);
  flex-shrink: 0;
  padding-top: 2px;
}
.card-list .list-text {
  font-size: 15px;
  color: var(--gray);
  line-height: 1.5;
}

/* -- END card -- */
.card-end {
  text-align: center;
}
.card-end .end-icon {
  font-size: 32px;
  margin-bottom: 16px;
  opacity: 0.5;
}
.card-end h2 {
  font-size: 20px;
  color: var(--white);
  margin-bottom: 8px;
}
.card-end .end-source {
  font-size: 13px;
  color: var(--muted);
  margin-bottom: 24px;
}
.card-end .end-actions {
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
}
.card-end .end-btn {
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  border: none;
  font-family: var(--font);
  text-decoration: none;
}
.card-end .end-btn.primary {
  background: var(--green);
  color: #000;
}
.card-end .end-btn.primary:hover { background: var(--green-hover); }
.card-end .end-btn.secondary {
  background: var(--surface);
  color: var(--gray);
  border: 1px solid var(--border);
}
.card-end .end-btn.secondary:hover { border-color: var(--muted); color: var(--white); }

/* === NAVIGATION HINTS === */
.nav-hint {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 40px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--dim);
  font-size: 20px;
  cursor: pointer;
  z-index: 10;
  opacity: 0;
  transition: opacity 0.3s;
}
.card-viewport:hover .nav-hint { opacity: 1; }
.nav-hint:hover { color: var(--muted); }
.nav-hint.left { left: 8px; }
.nav-hint.right { right: 8px; }

/* === BOTTOM BAR === */
.story-footer {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  border-top: 1px solid var(--border);
  flex-shrink: 0;
  gap: 16px;
  font-size: 12px;
  color: var(--dim);
}
.story-footer .counter {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--muted);
}
.story-footer .tip {
  color: var(--dim);
}

/* === LOADING STATE === */
.story-loading {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--bg);
  z-index: 1001;
}
.story-loading .spinner {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border);
  border-top-color: var(--green);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 16px;
}
@keyframes spin { to { transform: rotate(360deg); } }
.story-loading p {
  font-size: 13px;
  color: var(--muted);
}

/* === RESPONSIVE === */
@media (max-width: 480px) {
  .story-card { padding: 32px 20px; }
  .story-bar .source-url { display: none; }
  .nav-hint { display: none; }
}

/* === ENTRY ANIMATION === */
@keyframes cardIn {
  from { opacity: 0; transform: scale(0.96) translateY(12px); }
  to { opacity: 1; transform: scale(1) translateY(0); }
}
.story-card.active .card-inner {
  animation: cardIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) both;
}
</style>
</head>
<body>

<!-- LOADING -->
<div class="story-loading" id="story-loading">
  <div class="spinner"></div>
  <p>Loading story...</p>
</div>

<!-- STORY CONTAINER -->
<div class="story-container" id="story-container" style="display:none;">

  <!-- Top bar -->
  <div class="story-bar">
    <span class="logo">D2D</span>
    <span class="mode-tag">STORY MODE</span>
    <span class="spacer"></span>
    <span class="source-url" id="source-url"></span>
    <button class="story-close" onclick="exitStory()" title="Close">&times;</button>
  </div>

  <!-- Progress -->
  <div class="progress-track" id="progress-track"></div>

  <!-- Card viewport -->
  <div class="card-viewport" id="card-viewport">
    <div class="nav-hint left" onclick="prevCard()">&#8249;</div>
    <div class="nav-hint right" onclick="nextCard()">&#8250;</div>
  </div>

  <!-- Bottom -->
  <div class="story-footer">
    <span class="counter" id="counter">1 / 1</span>
    <span class="tip">tap or swipe to navigate</span>
  </div>

</div>

<script>
// ═══════════════════════════════════════
// STORY MODE ENGINE v2
// Deterministic structure: headline → overview → sections → end
// No duplicate content. Each paragraph used once.
// ═══════════════════════════════════════

const API = location.hostname === 'localhost' ? '' : 'https://fortune0-com.onrender.com';
let cards = [];
let currentIndex = 0;
let touchStartX = 0;
let touchStartY = 0;

// ── Source badge helper ──
// Shows D2D green dot for our domains, neutral for external
const D2D_DOMAINS = [
  'death2data.com','fortune0.com','soulfra.ai','deathtodata.github.io',
  'vibe-browser.com','installkernel.com','brandaidkit.com'
];
function sourceBadge(domain) {
  const isOurs = D2D_DOMAINS.some(d => domain.includes(d));
  if (isOurs) {
    return `<span style="display:inline-flex;align-items:center;gap:5px;font-size:11px;padding:3px 8px;background:var(--green-dim);border:1px solid #0c3;border-radius:12px;color:var(--green);">
      <span style="width:6px;height:6px;background:var(--green);border-radius:50%;"></span>D2D verified
    </span>`;
  }
  return `<span style="display:inline-flex;align-items:center;gap:5px;font-size:11px;padding:3px 8px;background:var(--surface);border:1px solid var(--border);border-radius:12px;color:var(--muted);">
    <img src="https://www.google.com/s2/favicons?domain=${esc(domain)}&sz=32" style="width:12px;height:12px;border-radius:2px;" onerror="this.style.display='none'">${esc(domain)}
  </span>`;
}

// ── Parse content into story cards (no duplication) ──
function parseContentToCards(data) {
  const { title, url, content, headings } = data;
  const domain = url ? url.replace(/^https?:\/\//, '').split('/')[0] : '';
  const cards = [];
  const usedText = new Set(); // track used content to prevent dupes

  function isUsed(text) {
    const key = text.trim().slice(0, 60).toLowerCase();
    if (usedText.has(key)) return true;
    usedText.add(key);
    return false;
  }

  // ── Card 1: HEADLINE (always) ──
  cards.push({
    type: 'headline',
    html: `<div class="card-inner card-headline">
      <div class="card-label">Story Mode</div>
      <h1>${esc(title)}</h1>
      <div class="card-source" style="display:flex;align-items:center;gap:10px;">
        ${sourceBadge(domain)}
      </div>
    </div>`
  });
  isUsed(title);

  // ── Card 2: KEY POINTS overview (if we have 3+ headings) ──
  const validHeadings = (headings || []).filter(h => h.text && h.text.length > 3 && h.snippet && h.snippet.length > 20);

  if (validHeadings.length >= 3) {
    const listHtml = validHeadings.slice(0, 6).map((h, i) =>
      `<div class="list-item">
        <span class="list-num">${String(i+1).padStart(2,'0')}</span>
        <span class="list-text">${esc(h.text)}</span>
      </div>`
    ).join('');
    cards.push({
      type: 'list',
      html: `<div class="card-inner card-list">
        <h3>What&rsquo;s in this story</h3>
        ${listHtml}
      </div>`
    });
  }

  // ── Section cards: one per heading with snippet ──
  // These are the ONLY place heading content appears (no duplication with body)
  validHeadings.forEach((h, i) => {
    isUsed(h.text);
    isUsed(h.snippet);
    cards.push({
      type: 'keypoint',
      html: `<div class="card-inner card-keypoint">
        <div class="kp-number">${String(i+1).padStart(2,'0')}</div>
        <h2>${esc(h.text)}</h2>
        <p>${esc(h.snippet)}</p>
      </div>`
    });
  });

  // ── Parse remaining paragraphs that weren't used in headings ──
  if (content && content.length > 0) {
    const allParas = content.split('\n').filter(p => p.trim().length > 40);
    const unusedParas = allParas.filter(p => !isUsed(p));

    // Find ONE stat (first number-heavy paragraph)
    const statIdx = unusedParas.findIndex(p => /\b\d{1,3}%|\$[\d,.]+[BMK]?\b/.test(p));
    if (statIdx !== -1) {
      const statPara = unusedParas.splice(statIdx, 1)[0];
      const statMatch = statPara.match(/(\$[\d,.]+[BMK]?|\d{1,3}%)/);
      if (statMatch) {
        cards.push({
          type: 'stat',
          html: `<div class="card-inner card-stat">
            <div class="stat-value">${esc(statMatch[1])}</div>
            <div class="stat-label">${esc(statPara.slice(0, 100))}</div>
          </div>`
        });
      }
    }

    // Find ONE quote
    const quoteIdx = unusedParas.findIndex(p =>
      (/^[""\u201C]/.test(p.trim()) || /\bsaid\b|\bsays\b/.test(p)) && p.length < 280
    );
    if (quoteIdx !== -1) {
      const quotePara = unusedParas.splice(quoteIdx, 1)[0];
      const clean = quotePara.replace(/^[""\u201C]+|[""\u201D]+$/g, '').trim();
      // Split quote from attribution if "says X" pattern
      const saidSplit = clean.match(/^(.+?)[,"]?\s+says?\s+(.+)$/i);
      cards.push({
        type: 'quote',
        html: `<div class="card-inner card-quote">
          <div class="quote-mark">&ldquo;</div>
          <blockquote>${esc(saidSplit ? saidSplit[1] : clean)}</blockquote>
          ${saidSplit ? `<div class="quote-attr">&mdash; ${esc(saidSplit[2])}</div>` : ''}
        </div>`
      });
    }

    // Remaining body paragraphs — max 3 cards, 1-2 paragraphs each
    const bodyParas = unusedParas.filter(p => p.length > 50 && p.length < 500).slice(0, 4);
    for (let i = 0; i < bodyParas.length; i += 2) {
      const chunk = bodyParas.slice(i, i + 2);
      cards.push({
        type: 'body',
        html: `<div class="card-inner card-body">
          ${chunk.map(p => `<p>${esc(p)}</p>`).join('')}
        </div>`
      });
    }
  }

  // ── END card (always) ──
  cards.push({
    type: 'end',
    html: `<div class="card-inner card-end">
      <div class="end-icon">&#9679;</div>
      <h2>End of story</h2>
      <div class="end-source">${sourceBadge(domain)}</div>
      <div class="end-actions">
        <a class="end-btn secondary" href="${esc(url)}" target="_blank" rel="noopener">View original</a>
        <button class="end-btn primary" onclick="exitStory()">Back to search</button>
      </div>
    </div>`
  });

  // Guarantee at least 3 cards (headline + something + end)
  if (cards.length < 3 && data.raw) {
    const fallback = data.raw.slice(0, 600).trim();
    cards.splice(cards.length - 1, 0, {
      type: 'body',
      html: `<div class="card-inner card-body"><p>${esc(fallback)}</p></div>`
    });
  }

  return cards;
}

function esc(s) {
  if (!s) return '';
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ── Render cards into viewport ──
function renderCards() {
  const viewport = document.getElementById('card-viewport');
  const track = document.getElementById('progress-track');

  track.innerHTML = cards.map((_, i) =>
    `<div class="progress-seg" id="seg-${i}"><div class="progress-fill"></div></div>`
  ).join('');

  let html = '';
  cards.forEach((card, i) => {
    html += `<div class="story-card ${i === 0 ? 'active' : 'entering-right'}" id="card-${i}">${card.html}</div>`;
  });
  viewport.innerHTML = html +
    '<div class="nav-hint left" onclick="prevCard()">&#8249;</div>' +
    '<div class="nav-hint right" onclick="nextCard()">&#8250;</div>';

  updateProgress();
  updateCounter();
}

function updateProgress() {
  cards.forEach((_, i) => {
    const seg = document.getElementById('seg-' + i);
    if (!seg) return;
    seg.className = 'progress-seg';
    if (i < currentIndex) seg.classList.add('done');
    else if (i === currentIndex) seg.classList.add('active');
  });
}

function updateCounter() {
  document.getElementById('counter').textContent =
    `${currentIndex + 1} / ${cards.length}`;
}

// ── Navigate ──
function goToCard(index) {
  if (index < 0 || index >= cards.length) return;
  const oldCard = document.getElementById('card-' + currentIndex);
  const newCard = document.getElementById('card-' + index);
  if (!oldCard || !newCard) return;

  const goingForward = index > currentIndex;
  oldCard.className = 'story-card';
  newCard.className = 'story-card';
  newCard.classList.add(goingForward ? 'entering-right' : 'entering-left');
  newCard.offsetWidth; // force reflow
  oldCard.classList.add(goingForward ? 'prev' : 'entering-right');
  newCard.classList.remove('entering-right', 'entering-left');
  newCard.classList.add('active');

  currentIndex = index;
  updateProgress();
  updateCounter();
}

function nextCard() { if (currentIndex < cards.length - 1) goToCard(currentIndex + 1); }
function prevCard() { if (currentIndex > 0) goToCard(currentIndex - 1); }

// ── Touch + click ──
function setupTouch() {
  const vp = document.getElementById('card-viewport');

  vp.addEventListener('touchstart', e => {
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
  }, { passive: true });

  vp.addEventListener('touchend', e => {
    const dx = e.changedTouches[0].screenX - touchStartX;
    const dy = e.changedTouches[0].screenY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 50) {
      dx < 0 ? nextCard() : prevCard();
    }
  }, { passive: true });

  vp.addEventListener('click', e => {
    if (e.target.closest('.nav-hint,.end-btn,a,button')) return;
    const rect = vp.getBoundingClientRect();
    const x = e.clientX - rect.left;
    x < rect.width * 0.35 ? prevCard() : nextCard();
  });
}

// ── Keyboard ──
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); nextCard(); }
  if (e.key === 'ArrowLeft') { e.preventDefault(); prevCard(); }
  if (e.key === 'Escape') exitStory();
});

// ── Exit ──
function exitStory() {
  if (document.referrer && document.referrer.includes(location.hostname)) {
    window.history.back();
  } else {
    window.location.href = '/';
  }
}

// ── Fetch content through D2D privacy layer ──
async function loadStory(url) {
  try {
    const token = localStorage.getItem('d2d_token');
    const headers = {};
    if (token) headers['Authorization'] = 'Bearer ' + token;

    const r = await fetch(`${API}/fetch?url=${encodeURIComponent(url)}`, { headers });
    const data = await r.json();
    if (data.error) throw new Error(data.error);

    const parser = new DOMParser();
    const doc = parser.parseFromString(data.content, 'text/html');
    doc.querySelectorAll('script,style,nav,footer,header,iframe,noscript,.ad,.ads,.sidebar,.menu,.nav,aside').forEach(el => el.remove());

    const title = doc.querySelector('title')?.textContent || doc.querySelector('h1')?.textContent || url;

    // Headings with snippets
    const headings = [];
    doc.querySelectorAll('h1,h2,h3').forEach(h => {
      const text = h.textContent.trim();
      if (!text || text.length < 3 || text.length > 120) return;
      let snippet = '';
      let next = h.nextElementSibling;
      let tries = 0;
      while (next && tries < 5) {
        if (['H1','H2','H3'].includes(next.tagName)) break;
        const p = next.tagName === 'P' ? next : next.querySelector?.('p');
        if (p && p.textContent.trim().length > 20) { snippet = p.textContent.trim(); break; }
        next = next.nextElementSibling;
        tries++;
      }
      headings.push({ text, snippet });
    });

    // Paragraphs
    const main = doc.querySelector('article') || doc.querySelector('main') || doc.querySelector('.content') || doc.body;
    const textParts = [];
    main.querySelectorAll('p,li,blockquote').forEach(el => {
      const t = el.textContent.trim();
      if (t.length > 20) textParts.push(t);
    });

    return { title, url, headings, content: textParts.join('\n'), raw: main.textContent.trim() };
  } catch (e) {
    console.error('Story load error:', e);
    return null;
  }
}

// ── DEMO ──
function loadDemo() {
  const demoData = {
    title: 'The Future of Privacy-First Search',
    url: 'https://death2data.com/about',
    headings: [
      { text: 'The Surveillance Economy is Crumbling', snippet: 'Major browsers are blocking third-party cookies by default. Users are demanding alternatives to the ad-funded search model that has dominated for two decades.' },
      { text: 'Privacy Search Goes Mainstream', snippet: 'DuckDuckGo crossed 100 million daily searches. Brave Search, Startpage, and newer privacy-first entrants are growing 40% year over year.' },
      { text: 'The Dollar Model', snippet: 'When you pay $1 for search, the incentive to track you disappears entirely. You are the customer, not the product. The economics actually work.' },
      { text: 'Local-First Architecture', snippet: 'Next-generation privacy tools keep everything on your device. No cloud storage. No server-side logs. No attack surface for breaches.' },
      { text: 'What Comes Next', snippet: 'Local AI models, encrypted search indexes, and wallet-based identity will converge into a new kind of web — one where you own your data by default.' }
    ],
    content: '"The idea that search must be funded by surveillance is a myth we created to justify the business model," says one privacy researcher at the Electronic Frontier Foundation.\n\n$47B was spent on search advertising in the US alone last year. Even capturing a fraction of that market through direct subscriptions represents a massive opportunity for privacy-first alternatives.\n\nThe tools exist today. What was missing was the economic model. At one dollar per month, with no tracking and no ads, the math works for both users and the builders creating these alternatives.'
  };

  cards = parseContentToCards(demoData);
  document.getElementById('source-url').textContent = 'death2data.com';
  renderCards();
  setupTouch();
  document.getElementById('story-loading').style.display = 'none';
  document.getElementById('story-container').style.display = 'flex';
}

// ── INIT ──
(async function init() {
  const params = new URLSearchParams(location.search);
  const url = params.get('url');

  if (url) {
    document.getElementById('source-url').textContent = url.replace(/^https?:\/\//, '').split('/')[0];
    const data = await loadStory(url);
    if (data) {
      cards = parseContentToCards(data);
      renderCards();
      setupTouch();
      document.getElementById('story-loading').style.display = 'none';
      document.getElementById('story-container').style.display = 'flex';
    } else {
      window.location.href = url;
    }
  } else {
    loadDemo();
  }
})();
</script>

</body>
</html>
