<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Data Sanitizer | Death2Data</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: #0a0a0a;
  color: #e0e0e0;
  min-height: 100vh;
}

:root {
  --green: #00cc44;
  --green-dim: rgba(0,204,68,0.1);
  --surface: #111;
  --border: #222;
  --muted: #666;
  --gray: #999;
  --red: #cc0000;
  --red-dim: rgba(204,0,0,0.1);
}

/* Nav */
.nav {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  background: #0a0a0a;
  position: sticky;
  top: 0;
  z-index: 100;
}
.nav .logo { font-weight: 700; color: var(--green); letter-spacing: 1px; font-size: 15px; margin-right: auto; }
.nav a { font-size: 12px; color: var(--muted); text-decoration: none; }
.nav a:hover { color: #e0e0e0; }

/* Main */
.main {
  max-width: 600px;
  margin: 0 auto;
  padding: 40px 16px 80px;
}

h1 { font-size: 22px; font-weight: 600; margin-bottom: 6px; }
.subtitle { font-size: 13px; color: var(--muted); margin-bottom: 32px; }

/* Drop zone */
.drop-zone {
  border: 2px dashed var(--border);
  border-radius: 12px;
  padding: 48px 24px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  margin-bottom: 24px;
}
.drop-zone:hover, .drop-zone.dragover {
  border-color: var(--green);
  background: var(--green-dim);
}
.drop-zone .icon { font-size: 32px; margin-bottom: 12px; }
.drop-zone .label { font-size: 14px; color: var(--gray); margin-bottom: 4px; }
.drop-zone .hint { font-size: 11px; color: var(--muted); }
.drop-zone input { display: none; }

/* Results */
.results { display: none; }
.results.show { display: block; }

.file-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 12px;
}
.file-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
}
.file-name {
  font-size: 14px;
  font-weight: 600;
  word-break: break-all;
}
.file-size { font-size: 11px; color: var(--muted); }

.meta-table {
  width: 100%;
  margin-bottom: 16px;
}
.meta-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #1a1a1a;
  font-size: 13px;
}
.meta-row:last-child { border-bottom: none; }
.meta-key { color: var(--muted); }
.meta-val { color: var(--gray); text-align: right; max-width: 60%; word-break: break-all; }
.meta-val.danger { color: var(--red); }
.meta-val.safe { color: var(--green); }

.meta-section {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin: 16px 0 8px;
}

.strip-btn {
  display: block;
  width: 100%;
  padding: 14px;
  background: var(--green);
  color: #000;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  font-family: inherit;
  margin-top: 8px;
}
.strip-btn:hover { background: #00e64d; }
.strip-btn:disabled { background: #333; color: #666; cursor: not-allowed; }

.status-badge {
  display: inline-block;
  font-size: 11px;
  padding: 3px 8px;
  border-radius: 12px;
}
.status-badge.dirty { background: var(--red-dim); color: var(--red); }
.status-badge.clean { background: var(--green-dim); color: var(--green); }

.summary {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px 20px;
  margin-bottom: 16px;
  font-size: 13px;
  line-height: 1.6;
  color: var(--gray);
}

.another-btn {
  display: block;
  width: 100%;
  padding: 14px;
  background: none;
  border: 1px solid var(--border);
  color: var(--muted);
  border-radius: 8px;
  font-size: 13px;
  cursor: pointer;
  font-family: inherit;
  margin-top: 8px;
}
.another-btn:hover { border-color: var(--green); color: var(--green); }
</style>

<meta name="description" content="Strip metadata from images and files before sharing. EXIF, GPS, camera info — removed locally. Nothing uploaded.">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">
<meta name="theme-color" content="#0a0a0a">
</head>
<body>

<nav class="nav">
  <span class="logo">D2D</span>
  <a href="/">Search</a>
  <a href="/about.html">About</a>
  <a href="/tools.html">Tools</a>
</nav>

<div class="main">
  <h1>Data Sanitizer</h1>
  <p class="subtitle">Strip hidden metadata from images before sharing. Everything runs locally — nothing leaves your device.</p>

  <div class="drop-zone" id="dropZone">
    <div class="icon">&#128391;</div>
    <div class="label">Drop an image here or click to select</div>
    <div class="hint">Supports JPEG, PNG, WebP. Max 25MB.</div>
    <input type="file" id="fileInput" accept="image/jpeg,image/png,image/webp" multiple>
  </div>

  <div class="results" id="results"></div>
</div>

<script>
// ═══════════════════════════════════════
// DATA SANITIZER — Client-side EXIF stripper
// No uploads. No server. All local.
// ═══════════════════════════════════════

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const results = document.getElementById('results');

// ── Drop zone handlers ──
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', () => handleFiles(fileInput.files));

function handleFiles(files) {
  results.innerHTML = '';
  results.classList.add('show');
  Array.from(files).forEach(f => processFile(f));
}

function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// ── EXIF parser (JPEG) ──
function readExif(buffer) {
  const view = new DataView(buffer);
  const meta = {};

  // Check JPEG magic bytes
  if (view.getUint16(0) !== 0xFFD8) return meta;

  let offset = 2;
  while (offset < view.byteLength - 2) {
    const marker = view.getUint16(offset);

    // Categorize marker
    if ((marker & 0xFF00) !== 0xFF00) break;
    const len = view.getUint16(offset + 2);
    const segData = buffer.slice(offset + 4, offset + 2 + len);

    // APP1 = EXIF / XMP
    if (marker === 0xFFE1) {
      const exifView = new DataView(segData);
      const header = String.fromCharCode(
        exifView.getUint8(0), exifView.getUint8(1),
        exifView.getUint8(2), exifView.getUint8(3)
      );

      if (header === 'Exif') {
        meta._hasExif = true;

        // Parse TIFF header for readable tags
        const tiffOffset = 6;
        const littleEndian = exifView.getUint16(tiffOffset) === 0x4949;

        try {
          const ifdOffset = exifView.getUint32(tiffOffset + 4, littleEndian);
          const ifdCount = exifView.getUint16(tiffOffset + ifdOffset, littleEndian);

          for (let i = 0; i < Math.min(ifdCount, 50); i++) {
            const entryOffset = tiffOffset + ifdOffset + 2 + (i * 12);
            if (entryOffset + 12 > segData.byteLength) break;

            const tag = exifView.getUint16(entryOffset, littleEndian);
            const type = exifView.getUint16(entryOffset + 2, littleEndian);
            const count = exifView.getUint32(entryOffset + 4, littleEndian);

            const readStr = (off, n) => {
              let s = '';
              for (let j = 0; j < Math.min(n, 64); j++) {
                const c = exifView.getUint8(off + j);
                if (c === 0) break;
                s += String.fromCharCode(c);
              }
              return s.trim();
            };

            let valOffset = entryOffset + 8;
            if (type === 2 && count > 4) {
              valOffset = tiffOffset + exifView.getUint32(entryOffset + 8, littleEndian);
            }

            const tagMap = {
              0x010F: 'Camera Make', 0x0110: 'Camera Model',
              0x0131: 'Software', 0x0132: 'Date/Time',
              0x013B: 'Artist', 0x8298: 'Copyright',
              0x9003: 'Date Original', 0x9004: 'Date Digitized',
              0xA434: 'Lens Model', 0x9286: 'User Comment',
              0x927C: 'Maker Note',
            };

            if (tagMap[tag] && type === 2 && valOffset + count <= segData.byteLength) {
              const val = readStr(valOffset, count);
              if (val) meta[tagMap[tag]] = val;
            }
          }
        } catch (e) { /* EXIF parsing is best-effort */ }

        // Scan for GPS IFD marker
        const exifBytes = new Uint8Array(segData);
        for (let i = 0; i < exifBytes.length - 1; i++) {
          if (exifBytes[i] === 0x88 && exifBytes[i + 1] === 0x25) {
            meta['GPS Data'] = 'Present (your location is embedded)';
            break;
          }
        }
      }

      // Check if it's XMP in APP1
      const xmpSig = 'http://ns.adobe.com/xap/1.0/';
      const segStr = new TextDecoder('ascii', { fatal: false }).decode(new Uint8Array(segData).slice(0, 64));
      if (segStr.includes(xmpSig)) {
        meta['XMP Data'] = 'Present (Adobe/editing metadata)';
        meta._hasXMP = true;
      }
    }

    // APP2 = ICC Profile (can contain PII)
    if (marker === 0xFFE2) {
      meta['ICC Profile'] = 'Present (color profile — may contain device info)';
    }

    // APP3-APP11 = Vendor-specific (Samsung, Qualcomm, etc.)
    if (marker >= 0xFFE3 && marker <= 0xFFEB) {
      meta['Vendor Metadata (APP' + (marker - 0xFFE0) + ')'] = 'Present (device-specific data)';
    }

    // APP12 = Picture Info / Ducky
    if (marker === 0xFFEC) {
      meta['APP12 (Ducky/PictureInfo)'] = 'Present';
    }

    // APP13 = IPTC / Photoshop
    if (marker === 0xFFED) {
      meta['IPTC Data'] = 'Present (Photoshop/news metadata — may contain author, caption, location)';
    }

    // APP14 = Adobe
    if (marker === 0xFFEE) {
      meta['Adobe Metadata'] = 'Present';
    }

    // COM = JPEG Comment (0xFFFE) — can contain ANYTHING
    if (marker === 0xFFFE) {
      const commentBytes = new Uint8Array(segData);
      const comment = new TextDecoder('utf-8', { fatal: false }).decode(commentBytes).trim();
      meta['JPEG Comment'] = comment.length > 80 ? comment.slice(0, 80) + '...' : (comment || 'Present');
    }

    offset += 2 + len;
  }

  return meta;
}

// ── PNG metadata reader ──
function readPngMeta(buffer) {
  const view = new DataView(buffer);
  const meta = {};

  // PNG signature check
  if (view.getUint32(0) !== 0x89504E47) return meta;

  let offset = 8;
  const textChunks = [];

  while (offset < buffer.byteLength - 8) {
    const length = view.getUint32(offset);
    const type = String.fromCharCode(
      view.getUint8(offset + 4), view.getUint8(offset + 5),
      view.getUint8(offset + 6), view.getUint8(offset + 7)
    );

    if (type === 'tEXt' || type === 'iTXt' || type === 'zTXt') {
      const chunk = new Uint8Array(buffer, offset + 8, Math.min(length, 512));
      const decoded = new TextDecoder('latin1').decode(chunk);
      const nullIdx = decoded.indexOf('\0');
      if (nullIdx > 0) {
        const key = decoded.slice(0, nullIdx);
        const val = decoded.slice(nullIdx + 1, nullIdx + 101).replace(/\0/g, '');
        if (key && val) {
          meta[key] = val.length > 80 ? val.slice(0, 80) + '...' : val;
        }
      }
      textChunks.push({ offset, length: length + 12, type });
    }

    if (type === 'eXIf') {
      meta['EXIF Chunk'] = 'Present';
      textChunks.push({ offset, length: length + 12, type });
    }

    offset += 12 + length;
    if (type === 'IEND') break;
  }

  meta._textChunks = textChunks;
  return meta;
}

// ── Strip ALL metadata from JPEG ──
// Keep ONLY: SOI, APP0 (JFIF — needed for display), DQT, DHT, SOF, SOS, image data
function stripJpeg(buffer) {
  const view = new DataView(buffer);
  if (view.getUint16(0) !== 0xFFD8) return buffer;

  const parts = [];
  parts.push(new Uint8Array(buffer, 0, 2)); // SOI marker

  // Markers that are SAFE to keep (essential for image display)
  const keepMarkers = new Set([
    0xFFE0, // APP0 — JFIF header (required)
    0xFFC0, // SOF0 — baseline
    0xFFC1, // SOF1
    0xFFC2, // SOF2 — progressive
    0xFFC4, // DHT — Huffman tables
    0xFFDB, // DQT — quantization tables
    0xFFDD, // DRI — restart interval
    0xFFDA, // SOS — start of scan
  ]);

  let offset = 2;
  while (offset < buffer.byteLength - 2) {
    const marker = view.getUint16(offset);

    // Start of scan = image data begins, keep everything from here
    if (marker === 0xFFDA) {
      parts.push(new Uint8Array(buffer, offset));
      break;
    }

    if ((marker & 0xFF00) !== 0xFF00) {
      parts.push(new Uint8Array(buffer, offset));
      break;
    }

    const len = view.getUint16(offset + 2);

    // ONLY keep markers that are essential for rendering
    // Everything else (APP1-APP15, COM, IPTC, XMP, ICC, vendor) gets stripped
    if (keepMarkers.has(marker)) {
      parts.push(new Uint8Array(buffer, offset, 2 + len));
    }
    // Else: silently drop it (this is the strip)

    offset += 2 + len;
  }

  const total = parts.reduce((a, b) => a + b.length, 0);
  const out = new Uint8Array(total);
  let pos = 0;
  for (const p of parts) {
    out.set(p, pos);
    pos += p.length;
  }
  return out.buffer;
}

// ── Strip metadata from PNG ──
function stripPng(buffer) {
  const view = new DataView(buffer);
  if (view.getUint32(0) !== 0x89504E47) return buffer;

  const parts = [];
  parts.push(new Uint8Array(buffer, 0, 8)); // PNG signature

  let offset = 8;
  const stripTypes = new Set(['tEXt', 'iTXt', 'zTXt', 'eXIf']);

  while (offset < buffer.byteLength - 8) {
    const length = view.getUint32(offset);
    const type = String.fromCharCode(
      view.getUint8(offset + 4), view.getUint8(offset + 5),
      view.getUint8(offset + 6), view.getUint8(offset + 7)
    );

    const chunkSize = 12 + length;

    if (!stripTypes.has(type)) {
      parts.push(new Uint8Array(buffer, offset, chunkSize));
    }

    offset += chunkSize;
    if (type === 'IEND') break;
  }

  const total = parts.reduce((a, b) => a + b.length, 0);
  const out = new Uint8Array(total);
  let pos = 0;
  for (const p of parts) {
    out.set(p, pos);
    pos += p.length;
  }
  return out.buffer;
}

// ── Process a file ──
async function processFile(file) {
  const buffer = await file.arrayBuffer();
  const isJpeg = file.type === 'image/jpeg';
  const isPng = file.type === 'image/png';

  let meta = {};
  if (isJpeg) meta = readExif(buffer);
  else if (isPng) meta = readPngMeta(buffer);

  // Filter out internal keys
  const displayMeta = {};
  for (const [k, v] of Object.entries(meta)) {
    if (!k.startsWith('_')) displayMeta[k] = v;
  }

  const metaCount = Object.keys(displayMeta).length;
  const hasGPS = !!displayMeta['GPS Data'];
  const isDirty = metaCount > 0;

  const card = document.createElement('div');
  card.className = 'file-card';

  let metaHTML = '';
  if (metaCount === 0) {
    metaHTML = '<div style="font-size:13px;color:var(--green);padding:12px 0;">No metadata found. This file looks clean.</div>';
  } else {
    metaHTML = '<div class="meta-section">Metadata found</div>';
    for (const [k, v] of Object.entries(displayMeta)) {
      const isDanger = k === 'GPS Data' || k === 'Artist' || k === 'Copyright';
      metaHTML += `<div class="meta-row">
        <span class="meta-key">${k}</span>
        <span class="meta-val ${isDanger ? 'danger' : ''}">${v}</span>
      </div>`;
    }
  }

  card.innerHTML = `
    <div class="file-header">
      <div>
        <div class="file-name">${file.name}</div>
        <div class="file-size">${formatSize(file.size)} · ${file.type.split('/')[1].toUpperCase()}</div>
      </div>
      <span class="status-badge ${isDirty ? 'dirty' : 'clean'}">${isDirty ? metaCount + ' fields found' : 'clean'}</span>
    </div>
    ${hasGPS ? '<div style="background:var(--red-dim);border:1px solid rgba(204,0,0,0.3);border-radius:6px;padding:10px 14px;margin-bottom:12px;font-size:12px;color:var(--red);">&#9888; GPS location data detected. This image contains your coordinates.</div>' : ''}
    <div class="meta-table">${metaHTML}</div>
    ${isDirty ? '<button class="strip-btn" id="strip-' + file.name.replace(/\W/g, '') + '">Strip all metadata & download clean copy</button>' : '<button class="another-btn" onclick="document.getElementById(\'fileInput\').click()">Sanitize another file</button>'}
  `;

  results.appendChild(card);

  // Wire up strip button
  if (isDirty) {
    const btn = card.querySelector('.strip-btn');
    btn.addEventListener('click', () => {
      let cleaned;
      if (isJpeg) cleaned = stripJpeg(buffer);
      else if (isPng) cleaned = stripPng(buffer);
      else {
        reencodeAndDownload(file, btn, card);
        return;
      }

      // ── VERIFY: re-scan the cleaned buffer to PROVE it's clean ──
      let verifyMeta = {};
      if (isJpeg) verifyMeta = readExif(cleaned);
      else if (isPng) verifyMeta = readPngMeta(cleaned);

      const remainingKeys = Object.keys(verifyMeta).filter(k => !k.startsWith('_'));
      const verified = remainingKeys.length === 0;

      const blob = new Blob([cleaned], { type: file.type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'clean-' + file.name;
      a.click();
      URL.revokeObjectURL(url);

      btn.textContent = verified ? '✓ Verified clean — downloaded' : 'Downloaded clean copy';
      btn.disabled = true;
      btn.style.background = 'var(--green-dim)';
      btn.style.color = 'var(--green)';

      // Show verification proof
      const proof = document.createElement('div');
      const saved = file.size - blob.size;
      if (verified) {
        proof.style.cssText = 'background:var(--green-dim);border:1px solid rgba(0,204,68,0.3);border-radius:6px;padding:12px 14px;margin-top:10px;font-size:12px;color:var(--green);line-height:1.5;';
        proof.innerHTML = `<strong>&#10003; Verified clean.</strong> Re-scanned output file — zero metadata fields remain.${saved > 0 ? ' Removed ' + formatSize(saved) + ' of hidden data.' : ''}`;
      } else {
        proof.style.cssText = 'background:rgba(204,136,0,0.1);border:1px solid rgba(204,136,0,0.3);border-radius:6px;padding:12px 14px;margin-top:10px;font-size:12px;color:#cc8800;line-height:1.5;';
        proof.innerHTML = `<strong>&#9888; Partial strip.</strong> ${remainingKeys.length} field(s) may remain in an unusual format. Use the nuclear option below for guaranteed clean output.`;
        const fallback = document.createElement('button');
        fallback.style.cssText = 'display:block;width:100%;margin-top:8px;padding:12px;background:var(--surface);color:var(--gray);border:1px solid var(--border);border-radius:8px;font-size:13px;cursor:pointer;font-family:inherit;';
        fallback.textContent = 'Re-encode via canvas (nuclear option — guaranteed clean)';
        fallback.onclick = () => reencodeAndDownload(file, fallback, card);
        proof.appendChild(fallback);
      }
      btn.after(proof);
    });
  }
}

// ── Fallback: re-encode via canvas (nuclear option — guaranteed clean) ──
// Canvas re-encoding creates brand new pixel data with ZERO metadata
function reencodeAndDownload(file, btn, card) {
  const img = new Image();
  img.onload = () => {
    const c = document.createElement('canvas');
    c.width = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext('2d').drawImage(img, 0, 0);

    c.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'clean-' + file.name.replace(/\.\w+$/, '.png'); // Always output PNG for max safety
      a.click();
      URL.revokeObjectURL(url);

      btn.textContent = '✓ Re-encoded & downloaded (guaranteed clean)';
      btn.disabled = true;
      btn.style.background = 'var(--green-dim)';
      btn.style.color = 'var(--green)';

      const proof = document.createElement('div');
      proof.style.cssText = 'background:var(--green-dim);border:1px solid rgba(0,204,68,0.3);border-radius:6px;padding:12px 14px;margin-top:10px;font-size:12px;color:var(--green);line-height:1.5;';
      proof.innerHTML = '<strong>&#10003; Guaranteed clean.</strong> Image was re-encoded from raw pixels. No original metadata can survive canvas re-encoding.';
      btn.after(proof);
    }, 'image/png');
  };
  img.src = URL.createObjectURL(file);
}
</script>

</body>
</html>
